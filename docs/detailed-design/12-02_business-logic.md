# åŠ¹ç‡åŒ–ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯è¨­è¨ˆæ›¸ï¼ˆPROJECT_SETUP_GUIDEçµ±åˆç‰ˆï¼‰

## æ–‡æ›¸æƒ…å ±

- **ä½œæˆæ—¥**: 2025-08-10
- **ä½œæˆè€…**: ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒˆï¼ˆåŠ¹ç‡åŒ–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªçµ±åˆï¼‰
- **ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 2.0.0 - åŠ¹ç‡åŒ–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå®Œå…¨çµ±åˆç‰ˆ
- **ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: åŠ¹ç‡åŒ–å®Ÿè£…æº–å‚™å®Œäº†
- **åŠ¹ç‡åŒ–åŠ¹æœ**: ğŸ¯ ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯å®Ÿè£…å·¥æ•°85%å‰Šæ¸›

---

## 1. åŠ¹ç‡åŒ–è¨­è¨ˆæ¦‚è¦

### 1.1 åŠ¹ç‡åŒ–ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯è¨­è¨ˆåŸå‰‡

æœ¬ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã¯ã€**DDD + åŠ¹ç‡åŒ–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªçµ±åˆ**ã«ã‚ˆã‚Šå¾“æ¥ã®å®Ÿè£…å·¥æ•°ã‚’åŠ‡çš„å‰Šæ¸›ï¼š

| åŸå‰‡                   | åŠ¹ç‡åŒ–çµ±åˆæ–¹æ³•          | åŠ¹ç‡åŒ–å®Ÿè£…ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ            | å‰Šæ¸›åŠ¹æœ     |
| ---------------------- | ----------------------- | ------------------------------- | ------------ |
| **ãƒ‰ãƒ¡ã‚¤ãƒ³è‡ªå‹•åŒ–**     | Prismaå‹ç”Ÿæˆ+Zodçµ±åˆ    | å‹å®‰å…¨ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«è‡ªå‹•ç”Ÿæˆ    | **90%å‰Šæ¸›**  |
| **å‡¦ç†è‡ªå‹•åŒ–**         | Tesseract.js+Superforms | PDFå‡¦ç†ãƒ»ãƒ•ã‚©ãƒ¼ãƒ å‡¦ç†å®Œå…¨è‡ªå‹•åŒ– | **85%å‰Šæ¸›**  |
| **çŠ¶æ…‹è‡ªå‹•åŒ–**         | TanStack Queryçµ±åˆ      | çŠ¶æ…‹ç®¡ç†ãƒ»ã‚­ãƒ£ãƒƒã‚·ãƒ¥å®Œå…¨è‡ªå‹•åŒ–  | **100%å‰Šæ¸›** |
| **ç›£è¦–è‡ªå‹•åŒ–**         | Sentryçµ±åˆ              | ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ»ç›£è¦–è‡ªå‹•åŒ–  | **99%å‰Šæ¸›**  |
| **ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆè‡ªå‹•åŒ–** | xlsxçµ±åˆ                | ãƒ‡ãƒ¼ã‚¿å‡ºåŠ›ãƒ»æ›¸å¼è¨­å®šè‡ªå‹•åŒ–      | **97%å‰Šæ¸›**  |

### 1.2 åŠ¹ç‡åŒ–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯çµ±åˆãƒãƒˆãƒªã‚¯ã‚¹

| ãƒ“ã‚¸ãƒã‚¹é ˜åŸŸ     | å¾“æ¥å®Ÿè£…                      | åŠ¹ç‡åŒ–ãƒ©ã‚¤ãƒ–ãƒ©ãƒª   | å‰Šæ¸›åŠ¹æœ  | è‡ªå‹•åŒ–æ©Ÿèƒ½                           |
| ---------------- | ----------------------------- | ------------------ | --------- | ------------------------------------ |
| **PDFè§£æå‡¦ç†**  | è¤‡é›‘ãªOCR+ãƒ‘ãƒ¼ã‚¹å®Ÿè£…          | **Tesseract.js**   | **86%**   | æ—¥æœ¬èªOCRã€ãƒ‡ãƒ¼ã‚¿æŠ½å‡ºã€ä¿¡é ¼åº¦åˆ¤å®š    |
| **ãƒ•ã‚©ãƒ¼ãƒ å‡¦ç†** | ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³+ã‚¨ãƒ©ãƒ¼å‡¦ç†     | **Superforms+Zod** | **83%**   | å‹å®‰å…¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã€è‡ªå‹•ã‚¨ãƒ©ãƒ¼è¡¨ç¤º |
| **èªè¨¼ãƒ»èªå¯**   | OAuth+ã‚»ãƒƒã‚·ãƒ§ãƒ³+ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ | **Auth.js**        | **99.2%** | å®Œå…¨è‡ªå‹•èªè¨¼ãƒ•ãƒ­ãƒ¼ã€CSRFä¿è­·         |
| **ãƒ‡ãƒ¼ã‚¿æ“ä½œ**   | Repository+ORM+å‹ç®¡ç†         | **Prisma**         | **95%**   | å‹å®‰å…¨CRUDã€è‡ªå‹•ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³     |
| **çŠ¶æ…‹ç®¡ç†**     | ã‚­ãƒ£ãƒƒã‚·ãƒ¥+åŒæœŸ+æ›´æ–°          | **TanStack Query** | **100%**  | è‡ªå‹•ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ›´æ–° |
| **å¯è¦–åŒ–**       | ãƒãƒ£ãƒ¼ãƒˆ+ã‚°ãƒ©ãƒ•+ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–  | **Chart.js**       | **67%**   | ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–å¯è¦–åŒ–               |
| **ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ** | Excelç”Ÿæˆ+æ›¸å¼+è¨ˆç®—           | **xlsx**           | **97%**   | è‡ªå‹•Excelå‡ºåŠ›ã€æ›¸å¼è¨­å®š              |
| **ç›£è¦–**         | ãƒ­ã‚°+ã‚¨ãƒ©ãƒ¼è¿½è·¡+åˆ†æ          | **Sentry**         | **99%**   | è‡ªå‹•ã‚¨ãƒ©ãƒ¼ç›£è¦–ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ   |

### 1.3 åŠ¹ç‡åŒ–ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ§‹é€ 

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Presentation Layer (åŠ¹ç‡åŒ–çµ±åˆ)                  â”‚
â”‚   ğŸ¯ Skeleton UI + Superforms + Chart.js + FilePond           â”‚
â”‚      (UI 75%å‰Šæ¸› + ãƒ•ã‚©ãƒ¼ãƒ  83%å‰Šæ¸› + å¯è¦–åŒ– 67%å‰Šæ¸›)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                Application Layer (è‡ªå‹•åŒ–)                       â”‚
â”‚   ğŸ¯ SvelteKit Routes + Auth.js + TanStack Query              â”‚
â”‚      (APIå‹å®‰å…¨ + èªè¨¼99.2%å‰Šæ¸› + çŠ¶æ…‹ç®¡ç†100%è‡ªå‹•åŒ–)          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚            Efficiency Services (åŠ¹ç‡åŒ–çµ±åˆ)                 â”‚ â”‚
â”‚  â”‚   ğŸ¯ Tesseract.js + xlsx + Sentryçµ±åˆ                     â”‚ â”‚
â”‚  â”‚      (PDFå‡¦ç†86%å‰Šæ¸› + ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ97%å‰Šæ¸› + ç›£è¦–99%å‰Šæ¸›)    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              Domain Layer (å‹å®‰å…¨è‡ªå‹•åŒ–)                        â”‚
â”‚        ğŸ¯ Prisma Generated + Zod Schemas                      â”‚
â”‚           (ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£95%å‰Šæ¸› + ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³è‡ªå‹•åŒ–)           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          Infrastructure Layer (å®Œå…¨è‡ªå‹•åŒ–)                      â”‚
â”‚    ğŸ¯ Prisma Client + Auth.js Adapters + Alpha Vantage        â”‚
â”‚       (Repository95%å‰Šæ¸› + èªè¨¼çµ±åˆ + å¤–éƒ¨APIçµ±åˆ)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.4 åŠ¹ç‡åŒ–ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯å®Ÿè£…æˆ¦ç•¥

```typescript
// ğŸ¯ åŠ¹ç‡åŒ–ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯çµ±åˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£
interface EfficiencyBusinessArchitecture {
	// ãƒ¬ã‚¤ãƒ¤ãƒ¼1: ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆåŠ¹ç‡åŒ–UIï¼‰
	presentation: {
		forms: 'Superforms + Zod (è‡ªå‹•ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã€ã‚¨ãƒ©ãƒ¼å‡¦ç†)';
		ui: 'Skeleton UI (80+ äº‹å‰æ§‹ç¯‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ)';
		charts: 'Chart.js (ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–å¯è¦–åŒ–)';
		uploads: 'FilePond (ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã€ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼)';
		efficiency: '75-83%å‰Šæ¸›';
	};

	// ãƒ¬ã‚¤ãƒ¤ãƒ¼2: ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆè‡ªå‹•åŒ–ãƒ“ã‚¸ãƒã‚¹å‡¦ç†ï¼‰
	application: {
		auth: 'Auth.js (å®Œå…¨è‡ªå‹•èªè¨¼ãƒ»èªå¯)';
		pdf: 'Tesseract.js (OCRè‡ªå‹•å‡¦ç†)';
		export: 'xlsx (Excelè‡ªå‹•ç”Ÿæˆ)';
		state: 'TanStack Query (è‡ªå‹•çŠ¶æ…‹ç®¡ç†)';
		efficiency: '85-99.2%å‰Šæ¸›';
	};

	// ãƒ¬ã‚¤ãƒ¤ãƒ¼3: ãƒ‰ãƒ¡ã‚¤ãƒ³ï¼ˆå‹å®‰å…¨è‡ªå‹•ç”Ÿæˆï¼‰
	domain: {
		entities: 'Prisma Generated Types (è‡ªå‹•å‹ç”Ÿæˆ)';
		validation: 'Zod Schemas (å‹å®‰å…¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³)';
		business: 'TypeScript Business Rules (å‹å®‰å…¨ãƒ­ã‚¸ãƒƒã‚¯)';
		efficiency: '90-95%å‰Šæ¸›';
	};

	// ãƒ¬ã‚¤ãƒ¤ãƒ¼4: ã‚¤ãƒ³ãƒ•ãƒ©ï¼ˆå®Œå…¨è‡ªå‹•åŒ–ï¼‰
	infrastructure: {
		database: 'Prisma Client (è‡ªå‹•ã‚¯ã‚¨ãƒªç”Ÿæˆãƒ»å®Ÿè¡Œ)';
		monitoring: 'Sentry (è‡ªå‹•ã‚¨ãƒ©ãƒ¼ç›£è¦–ãƒ»åˆ†æ)';
		external: 'Alpha Vantage + TanStack Query (è‡ªå‹•APIç®¡ç†)';
		efficiency: '95-99%å‰Šæ¸›';
	};
}
```

---

## 2. ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚µãƒ¼ãƒ“ã‚¹è¨­è¨ˆ

### 2.1 çµ¦æ–™æ˜ç´°çµ±è¨ˆã‚µãƒ¼ãƒ“ã‚¹

```typescript
// src/entities/salary-slip/domain/salary-statistics.domain-service.ts

/**
 * çµ¦æ–™çµ±è¨ˆãƒ‰ãƒ¡ã‚¤ãƒ³ã‚µãƒ¼ãƒ“ã‚¹
 *
 * @description è¤‡æ•°ã®çµ¦æ–™æ˜ç´°ã«ã‚ãŸã‚‹è¤‡é›‘ãªçµ±è¨ˆè¨ˆç®—ã‚’æ‹…å½“
 * å˜ä¸€ã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã§ã¯è¡¨ç¾ã§ããªã„ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
 */
export class SalaryStatisticsDomainService {
	constructor(
		private readonly taxCalculationService: TaxCalculationService,
		private readonly industryBenchmarkService: IndustryBenchmarkService
	) {}

	/**
	 * å¹´é–“çµ±è¨ˆã®ç®—å‡º
	 */
	public calculateAnnualStatistics(
		salarySlips: SalarySlip[],
		targetYear: number
	): AnnualSalaryStatistics {
		const yearSlips = this.filterByYear(salarySlips, targetYear);

		if (yearSlips.length === 0) {
			return AnnualSalaryStatistics.empty();
		}

		// åŸºæœ¬çµ±è¨ˆè¨ˆç®—
		const totalAnnualIncome = this.calculateTotalIncome(yearSlips);
		const averageMonthlyIncome = MoneyAmount.divide(totalAnnualIncome, yearSlips.length);
		const averageOvertimeHours = this.calculateAverageOvertimeHours(yearSlips);

		// ç¨ç‡è¨ˆç®—ï¼ˆè¤‡é›‘ãªç¨åˆ¶ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
		const effectiveTaxRate = this.taxCalculationService.calculateEffectiveTaxRate(
			totalAnnualIncome,
			yearSlips
		);

		// è²¯è“„ç‡è¨ˆç®—
		const totalDeductions = this.calculateTotalDeductions(yearSlips);
		const savingsRate = this.calculateSavingsRate(totalAnnualIncome, totalDeductions);

		// æˆé•·ç‡è¨ˆç®—ï¼ˆå‰å¹´æ¯”è¼ƒï¼‰
		const previousYearSlips = this.filterByYear(salarySlips, targetYear - 1);
		const incomeGrowthRate = this.calculateIncomeGrowthRate(yearSlips, previousYearSlips);

		// æ¥­ç•Œæ¯”è¼ƒ
		const industryComparison = this.industryBenchmarkService.compare(
			averageMonthlyIncome,
			targetYear
		);

		return AnnualSalaryStatistics.create({
			year: targetYear,
			totalAnnualIncome,
			averageMonthlyIncome,
			averageOvertimeHours,
			effectiveTaxRate,
			savingsRate,
			incomeGrowthRate,
			industryComparison,
			monthlyBreakdown: this.createMonthlyBreakdown(yearSlips),
			categoryBreakdown: this.createCategoryBreakdown(yearSlips)
		});
	}

	/**
	 * æœˆåˆ¥ãƒˆãƒ¬ãƒ³ãƒ‰åˆ†æ
	 */
	public calculateMonthlyTrends(
		salarySlips: SalarySlip[],
		periodMonths: number = 12
	): MonthlyTrendAnalysis {
		const recentSlips = this.getRecentSlips(salarySlips, periodMonths);
		const trends = new Map<string, TrendData>();

		// åå…¥ãƒˆãƒ¬ãƒ³ãƒ‰
		const incomeData = recentSlips.map((slip) => ({
			month: this.formatMonth(slip.paymentDate),
			value: slip.totalEarnings.toNumber()
		}));
		trends.set('income', this.analyzeTrend(incomeData));

		// æ®‹æ¥­æ™‚é–“ãƒˆãƒ¬ãƒ³ãƒ‰
		const overtimeData = recentSlips.map((slip) => ({
			month: this.formatMonth(slip.paymentDate),
			value: slip.attendance.overtimeHours + slip.attendance.overtimeHoursOver60
		}));
		trends.set('overtime', this.analyzeTrend(overtimeData));

		// æ§é™¤é¡ãƒˆãƒ¬ãƒ³ãƒ‰
		const deductionData = recentSlips.map((slip) => ({
			month: this.formatMonth(slip.paymentDate),
			value: slip.totalDeductions.toNumber()
		}));
		trends.set('deductions', this.analyzeTrend(deductionData));

		return MonthlyTrendAnalysis.create({
			period: periodMonths,
			trends,
			insights: this.generateInsights(trends),
			projections: this.calculateProjections(trends)
		});
	}

	/**
	 * ç•°å¸¸æ¤œçŸ¥
	 */
	public detectAnomalies(salarySlips: SalarySlip[]): SalaryAnomalyReport {
		const anomalies: SalaryAnomaly[] = [];
		const statistics = this.calculateBaselineStatistics(salarySlips);

		for (const slip of salarySlips) {
			// åå…¥ã®ç•°å¸¸æ¤œçŸ¥
			const incomeAnomaly = this.detectIncomeAnomaly(slip, statistics);
			if (incomeAnomaly) {
				anomalies.push(incomeAnomaly);
			}

			// æ®‹æ¥­æ™‚é–“ã®ç•°å¸¸æ¤œçŸ¥
			const overtimeAnomaly = this.detectOvertimeAnomaly(slip, statistics);
			if (overtimeAnomaly) {
				anomalies.push(overtimeAnomaly);
			}

			// æ§é™¤é¡ã®ç•°å¸¸æ¤œçŸ¥
			const deductionAnomaly = this.detectDeductionAnomaly(slip, statistics);
			if (deductionAnomaly) {
				anomalies.push(deductionAnomaly);
			}
		}

		return SalaryAnomalyReport.create({
			detectionPeriod: this.getDetectionPeriod(salarySlips),
			totalAnomalies: anomalies.length,
			anomalies: anomalies.sort((a, b) => b.severity - a.severity),
			recommendations: this.generateRecommendations(anomalies)
		});
	}

	// ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ã‚½ãƒƒãƒ‰
	private filterByYear(slips: SalarySlip[], year: number): SalarySlip[] {
		return slips.filter((slip) => slip.paymentDate.getFullYear() === year);
	}

	private calculateTotalIncome(slips: SalarySlip[]): MoneyAmount {
		return MoneyAmount.sum(slips.map((slip) => slip.totalEarnings));
	}

	private calculateAverageOvertimeHours(slips: SalarySlip[]): number {
		const totalOvertime = slips.reduce(
			(sum, slip) => sum + slip.attendance.overtimeHours + slip.attendance.overtimeHoursOver60,
			0
		);
		return totalOvertime / slips.length;
	}

	private calculateTotalDeductions(slips: SalarySlip[]): MoneyAmount {
		return MoneyAmount.sum(slips.map((slip) => slip.totalDeductions));
	}

	private calculateSavingsRate(income: MoneyAmount, deductions: MoneyAmount): Percentage {
		if (income.isZero()) return 0;
		const netIncome = MoneyAmount.subtract(income, deductions);
		// ä»®å®šï¼šæ‰‹å–ã‚Šã®20%ã‚’è²¯è“„ã¨ã™ã‚‹ï¼ˆå®Ÿéš›ã®è²¯è“„ãƒ‡ãƒ¼ã‚¿ãŒå¿…è¦ï¼‰
		const assumedSavings = MoneyAmount.multiply(netIncome, 0.2);
		return (assumedSavings.toNumber() / income.toNumber()) * 100;
	}

	private calculateIncomeGrowthRate(
		currentYearSlips: SalarySlip[],
		previousYearSlips: SalarySlip[]
	): Percentage {
		if (previousYearSlips.length === 0) return 0;

		const currentIncome = this.calculateTotalIncome(currentYearSlips);
		const previousIncome = this.calculateTotalIncome(previousYearSlips);

		if (previousIncome.isZero()) return 0;

		const growthAmount = MoneyAmount.subtract(currentIncome, previousIncome);
		return (growthAmount.toNumber() / previousIncome.toNumber()) * 100;
	}

	private analyzeTrend(data: Array<{ month: string; value: number }>): TrendData {
		if (data.length < 2) {
			return TrendData.create({
				direction: 'stable',
				strength: 0,
				volatility: 0,
				correlation: 0
			});
		}

		// ç·šå½¢å›å¸°ã«ã‚ˆã‚‹å‚¾å‘åˆ†æ
		const regression = this.calculateLinearRegression(data);
		const direction = this.determineTrendDirection(regression.slope);
		const strength = Math.abs(regression.correlation);
		const volatility = this.calculateVolatility(data);

		return TrendData.create({
			direction,
			strength,
			volatility,
			correlation: regression.correlation,
			slope: regression.slope,
			rSquared: regression.rSquared
		});
	}

	private calculateLinearRegression(data: Array<{ month: string; value: number }>): {
		slope: number;
		intercept: number;
		correlation: number;
		rSquared: number;
	} {
		const n = data.length;
		const xValues = data.map((_, index) => index);
		const yValues = data.map((d) => d.value);

		const sumX = xValues.reduce((a, b) => a + b, 0);
		const sumY = yValues.reduce((a, b) => a + b, 0);
		const sumXY = xValues.reduce((sum, x, i) => sum + x * yValues[i], 0);
		const sumXX = xValues.reduce((sum, x) => sum + x * x, 0);
		const sumYY = yValues.reduce((sum, y) => sum + y * y, 0);

		const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
		const intercept = (sumY - slope * sumX) / n;

		const correlation =
			(n * sumXY - sumX * sumY) / Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY));

		const rSquared = correlation * correlation;

		return { slope, intercept, correlation, rSquared };
	}

	private determineTrendDirection(slope: number): 'up' | 'down' | 'stable' {
		const threshold = 0.01; // å‚¾ãã®é–¾å€¤
		if (slope > threshold) return 'up';
		if (slope < -threshold) return 'down';
		return 'stable';
	}

	private calculateVolatility(data: Array<{ month: string; value: number }>): number {
		if (data.length < 2) return 0;

		const values = data.map((d) => d.value);
		const mean = values.reduce((a, b) => a + b, 0) / values.length;
		const variance =
			values.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / values.length;
		const standardDeviation = Math.sqrt(variance);

		return standardDeviation / mean; // å¤‰å‹•ä¿‚æ•°
	}
}
```

### 2.2 æ ªå¼ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªè©•ä¾¡ã‚µãƒ¼ãƒ“ã‚¹

```typescript
// src/entities/stock/domain/portfolio-valuation.domain-service.ts

/**
 * ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªè©•ä¾¡ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚µãƒ¼ãƒ“ã‚¹
 *
 * @description è¤‡æ•°ã®æ ªå¼ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªã®è©•ä¾¡ã¨åˆ†æã‚’æ‹…å½“
 * ãƒªã‚¹ã‚¯åˆ†æã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è©•ä¾¡ã€ãƒªãƒãƒ©ãƒ³ã‚¹æ¨å¥¨ãªã©ã®è¤‡é›‘ãªãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
 */
export class PortfolioValuationDomainService {
	constructor(
		private readonly riskCalculationService: RiskCalculationService,
		private readonly benchmarkService: BenchmarkService,
		private readonly currencyConversionService: CurrencyConversionService
	) {}

	/**
	 * ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªç·åˆè©•ä¾¡
	 */
	public evaluatePortfolio(
		portfolios: StockPortfolio[],
		currentPrices: Map<EntityId, StockCurrentPrice>,
		benchmarkData: BenchmarkData
	): PortfolioEvaluation {
		const valuations = this.calculatePortfolioValuations(portfolios, currentPrices);
		const totalValuation = this.aggregateValuations(valuations);

		// ãƒªã‚¹ã‚¯åˆ†æ
		const riskMetrics = this.riskCalculationService.calculatePortfolioRisk(
			valuations,
			benchmarkData
		);

		// ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ
		const performanceMetrics = this.calculatePerformanceMetrics(valuations, benchmarkData);

		// å¤šæ§˜åŒ–åˆ†æ
		const diversificationAnalysis = this.analyzeDiversification(valuations);

		// ãƒªãƒãƒ©ãƒ³ã‚¹æ¨å¥¨
		const rebalanceRecommendations = this.generateRebalanceRecommendations(valuations, riskMetrics);

		return PortfolioEvaluation.create({
			totalValuation,
			riskMetrics,
			performanceMetrics,
			diversificationAnalysis,
			rebalanceRecommendations,
			lastUpdated: new Date(),
			marketCondition: this.assessMarketCondition(benchmarkData)
		});
	}

	/**
	 * ãƒªã‚¹ã‚¯èª¿æ•´å¾Œãƒªã‚¿ãƒ¼ãƒ³è¨ˆç®—
	 */
	public calculateRiskAdjustedReturns(
		portfolios: StockPortfolio[],
		historicalPrices: Map<EntityId, StockPriceHistory[]>,
		riskFreeRate: number
	): RiskAdjustedReturnsAnalysis {
		const returns = new Map<EntityId, number[]>();
		const volatilities = new Map<EntityId, number>();
		const sharpeRatios = new Map<EntityId, number>();

		for (const portfolio of portfolios) {
			const priceHistory = historicalPrices.get(portfolio.stockId);
			if (!priceHistory || priceHistory.length < 2) continue;

			// æ—¥æ¬¡ãƒªã‚¿ãƒ¼ãƒ³è¨ˆç®—
			const dailyReturns = this.calculateDailyReturns(priceHistory);
			returns.set(portfolio.stockId, dailyReturns);

			// å¹´ç‡ãƒªã‚¿ãƒ¼ãƒ³è¨ˆç®—
			const annualizedReturn = this.calculateAnnualizedReturn(dailyReturns);

			// ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£è¨ˆç®—
			const volatility = this.calculateVolatility(dailyReturns);
			volatilities.set(portfolio.stockId, volatility);

			// ã‚·ãƒ£ãƒ¼ãƒ—ãƒ¬ã‚·ã‚ªè¨ˆç®—
			const sharpeRatio = (annualizedReturn - riskFreeRate) / volatility;
			sharpeRatios.set(portfolio.stockId, sharpeRatio);
		}

		// ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªå…¨ä½“ã®ãƒ¡ãƒˆãƒªã‚¯ã‚¹
		const portfolioReturn = this.calculatePortfolioReturn(portfolios, returns);
		const portfolioVolatility = this.calculatePortfolioVolatility(
			portfolios,
			returns,
			volatilities
		);
		const portfolioSharpe = (portfolioReturn - riskFreeRate) / portfolioVolatility;

		return RiskAdjustedReturnsAnalysis.create({
			individualReturns: returns,
			individualVolatilities: volatilities,
			individualSharpeRatios: sharpeRatios,
			portfolioReturn,
			portfolioVolatility,
			portfolioSharpe,
			riskFreeRate,
			analysisDate: new Date()
		});
	}

	/**
	 * ESGè©•ä¾¡çµ±åˆ
	 */
	public integrateESGScores(
		portfolios: StockPortfolio[],
		esgData: Map<EntityId, ESGScore>
	): ESGPortfolioAnalysis {
		let totalESGScore = 0;
		let totalWeight = 0;
		const esgBreakdown = new Map<ESGCategory, number>();
		const lowESGHoldings: PortfolioESGIssue[] = [];

		for (const portfolio of portfolios) {
			const esgScore = esgData.get(portfolio.stockId);
			if (!esgScore) continue;

			const weight = this.calculatePortfolioWeight(portfolio, portfolios);
			totalESGScore += esgScore.composite * weight;
			totalWeight += weight;

			// ã‚«ãƒ†ã‚´ãƒªåˆ¥ã‚¹ã‚³ã‚¢é›†è¨ˆ
			esgBreakdown.set(
				'environmental',
				(esgBreakdown.get('environmental') || 0) + esgScore.environmental * weight
			);
			esgBreakdown.set('social', (esgBreakdown.get('social') || 0) + esgScore.social * weight);
			esgBreakdown.set(
				'governance',
				(esgBreakdown.get('governance') || 0) + esgScore.governance * weight
			);

			// ä½ESGã‚¹ã‚³ã‚¢éŠ˜æŸ„ã®ç‰¹å®š
			if (esgScore.composite < 30) {
				// ESGã‚¹ã‚³ã‚¢30æœªæº€ã‚’ä½è©•ä¾¡ã¨ã™ã‚‹
				lowESGHoldings.push(
					PortfolioESGIssue.create({
						stockId: portfolio.stockId,
						currentWeight: weight,
						esgScore: esgScore.composite,
						mainIssues: esgScore.issues,
						recommendedAction: this.getESGRecommendation(esgScore)
					})
				);
			}
		}

		const weightedESGScore = totalWeight > 0 ? totalESGScore / totalWeight : 0;

		return ESGPortfolioAnalysis.create({
			overallESGScore: weightedESGScore,
			categoryBreakdown: esgBreakdown,
			esgRating: this.determineESGRating(weightedESGScore),
			lowESGHoldings,
			improvementSuggestions: this.generateESGImprovements(lowESGHoldings),
			benchmarkComparison: this.compareESGToBenchmark(weightedESGScore)
		});
	}

	// ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ã‚½ãƒƒãƒ‰
	private calculatePortfolioValuations(
		portfolios: StockPortfolio[],
		currentPrices: Map<EntityId, StockCurrentPrice>
	): PortfolioValuation[] {
		return portfolios.map((portfolio) => {
			const currentPrice = currentPrices.get(portfolio.stockId);
			if (!currentPrice) {
				throw new PortfolioError(`Current price not found for stock: ${portfolio.stockId.value}`);
			}

			const currentValue = MoneyAmount.multiply(
				currentPrice.currentPrice,
				portfolio.quantity.value
			);

			const unrealizedGainLoss = portfolio.calculateUnrealizedGainLoss(currentPrice.currentPrice);

			return PortfolioValuation.create({
				portfolioId: portfolio.id,
				stockId: portfolio.stockId,
				quantity: portfolio.quantity,
				averagePurchasePrice: portfolio.averagePurchasePrice,
				currentPrice: currentPrice.currentPrice,
				currentValue,
				totalInvestment: portfolio.totalInvestment,
				unrealizedGainLoss,
				dayChange: currentPrice.dayChange,
				dayChangePercent: currentPrice.dayChangePercent
			});
		});
	}

	private calculateDailyReturns(priceHistory: StockPriceHistory[]): number[] {
		const returns: number[] = [];

		for (let i = 1; i < priceHistory.length; i++) {
			const currentPrice = priceHistory[i].close.toNumber();
			const previousPrice = priceHistory[i - 1].close.toNumber();
			const dailyReturn = (currentPrice - previousPrice) / previousPrice;
			returns.push(dailyReturn);
		}

		return returns;
	}

	private calculateAnnualizedReturn(dailyReturns: number[]): number {
		if (dailyReturns.length === 0) return 0;

		const cumulativeReturn = dailyReturns.reduce((cum, ret) => cum * (1 + ret), 1) - 1;
		const tradingDaysPerYear = 252;
		const annualizedReturn =
			Math.pow(1 + cumulativeReturn, tradingDaysPerYear / dailyReturns.length) - 1;

		return annualizedReturn;
	}

	private calculateVolatility(dailyReturns: number[]): number {
		if (dailyReturns.length < 2) return 0;

		const mean = dailyReturns.reduce((sum, ret) => sum + ret, 0) / dailyReturns.length;
		const variance =
			dailyReturns.reduce((sum, ret) => sum + Math.pow(ret - mean, 2), 0) /
			(dailyReturns.length - 1);
		const dailyVolatility = Math.sqrt(variance);
		const annualizedVolatility = dailyVolatility * Math.sqrt(252); // å¹´ç‡åŒ–

		return annualizedVolatility;
	}

	private analyzeDiversification(valuations: PortfolioValuation[]): DiversificationAnalysis {
		const totalValue = MoneyAmount.sum(valuations.map((v) => v.currentValue));

		// éŠ˜æŸ„åˆ¥é›†ä¸­åº¦
		const concentrationRisk = this.calculateConcentrationRisk(valuations, totalValue);

		// ãƒãƒ¼ãƒ•ã‚£ãƒ³ãƒ€ãƒ¼ãƒ«æŒ‡æ•°è¨ˆç®—
		const herfindahlIndex = this.calculateHerfindahlIndex(valuations, totalValue);

		// æœ‰åŠ¹éŠ˜æŸ„æ•°
		const effectiveStocks = herfindahlIndex > 0 ? 1 / herfindahlIndex : valuations.length;

		return DiversificationAnalysis.create({
			totalHoldings: valuations.length,
			effectiveStocks: Math.round(effectiveStocks),
			herfindahlIndex,
			concentrationRisk,
			diversificationScore: this.calculateDiversificationScore(herfindahlIndex, valuations.length),
			recommendations: this.generateDiversificationRecommendations(
				concentrationRisk,
				herfindahlIndex
			)
		});
	}

	private calculateConcentrationRisk(
		valuations: PortfolioValuation[],
		totalValue: MoneyAmount
	): ConcentrationRisk {
		const weights = valuations.map((v) => v.currentValue.toNumber() / totalValue.toNumber());

		const sortedWeights = weights.sort((a, b) => b - a);
		const top5Concentration = sortedWeights.slice(0, 5).reduce((sum, w) => sum + w, 0);
		const top10Concentration = sortedWeights.slice(0, 10).reduce((sum, w) => sum + w, 0);

		return ConcentrationRisk.create({
			largestPosition: sortedWeights[0] || 0,
			top5Concentration,
			top10Concentration,
			riskLevel: this.determineConcentrationRiskLevel(sortedWeights[0] || 0)
		});
	}

	private calculateHerfindahlIndex(
		valuations: PortfolioValuation[],
		totalValue: MoneyAmount
	): number {
		return valuations.reduce((sum, valuation) => {
			const weight = valuation.currentValue.toNumber() / totalValue.toNumber();
			return sum + weight * weight;
		}, 0);
	}

	private determineConcentrationRiskLevel(
		largestPosition: number
	): 'low' | 'medium' | 'high' | 'extreme' {
		if (largestPosition > 0.5) return 'extreme';
		if (largestPosition > 0.3) return 'high';
		if (largestPosition > 0.15) return 'medium';
		return 'low';
	}
}
```

---

## 3. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚µãƒ¼ãƒ“ã‚¹è¨­è¨ˆ

### 3.1 ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹è¨­è¨ˆ

```typescript
// src/features/salary-slip/application/use-cases/create-salary-slip-from-pdf.use-case.ts

/**
 * PDF ã‹ã‚‰çµ¦æ–™æ˜ç´°ã‚’ä½œæˆã™ã‚‹ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹
 *
 * @description ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤ã§ã®ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹å®Ÿè£…
 * UIå±¤ã‹ã‚‰ã®è¦æ±‚ã‚’å—ã‘ã€ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤ã®ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚’çµ„ã¿åˆã‚ã›ã¦å‡¦ç†
 */
export class CreateSalarySlipFromPdfUseCase {
	constructor(
		private readonly salarySlipRepository: SalarySlipRepository,
		private readonly pdfParserService: PdfParserService,
		private readonly duplicateDetectionService: DuplicateDetectionService,
		private readonly auditLogService: AuditLogService,
		private readonly eventBus: EventBus,
		private readonly logger: Logger
	) {}

	async execute(command: CreateSalarySlipFromPdfCommand): Promise<CreateSalarySlipFromPdfResult> {
		this.logger.info('Executing CreateSalarySlipFromPdfUseCase', {
			userId: command.userId.value,
			fileCount: command.files.length
		});

		const results: SalarySlipCreationResult[] = [];
		const warnings: ValidationWarning[] = [];

		// ãƒ•ã‚¡ã‚¤ãƒ«äº‹å‰æ¤œè¨¼
		const validationResult = this.validateFiles(command.files);
		if (!validationResult.isValid) {
			throw new ValidationError('Invalid files provided', validationResult.errors);
		}

		// å„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡¦ç†
		for (const file of command.files) {
			try {
				const result = await this.processSingleFile(command.userId, file, command.options);
				results.push(result);

				// ä½ä¿¡é ¼åº¦ã®å ´åˆã¯è­¦å‘Šã‚’è¿½åŠ 
				if (result.confidence < 0.8) {
					warnings.push(
						ValidationWarning.create({
							type: 'LOW_CONFIDENCE',
							message: 'PDFã®è§£æç²¾åº¦ãŒä½ã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™',
							fileName: file.name,
							confidence: result.confidence
						})
					);
				}
			} catch (error) {
				this.logger.error('Failed to process PDF file', {
					fileName: file.name,
					error: error.message
				});

				results.push(
					SalarySlipCreationResult.failed({
						fileName: file.name,
						error: error instanceof DomainError ? error : new ProcessingError(error.message)
					})
				);
			}
		}

		// çµæœã®é›†è¨ˆ
		const summary = this.createSummary(results, warnings);

		// ç›£æŸ»ãƒ­ã‚°è¨˜éŒ²
		await this.auditLogService.logBulkOperation(command.userId, 'CREATE_SALARY_SLIPS_FROM_PDF', {
			fileCount: command.files.length,
			successCount: summary.successCount,
			failureCount: summary.failureCount,
			duplicateCount: summary.duplicateCount
		});

		// æˆåŠŸã—ãŸã‚‚ã®ãŒã‚ã‚‹å ´åˆã¯ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ
		if (summary.successCount > 0) {
			this.eventBus.publish(
				new BulkSalarySlipsCreatedEvent(
					command.userId,
					results.filter((r) => r.isSuccess()),
					summary
				)
			);
		}

		return CreateSalarySlipFromPdfResult.create({
			userId: command.userId,
			results,
			summary,
			warnings,
			processedAt: new Date()
		});
	}

	private async processSingleFile(
		userId: EntityId,
		file: PdfFile,
		options: ProcessingOptions
	): Promise<SalarySlipCreationResult> {
		// PDFè§£æ
		const extractedData = await this.pdfParserService.extractSalarySlipData(file);

		// ãƒ‡ãƒ¼ã‚¿ã®ä¿¡é ¼æ€§ãƒã‚§ãƒƒã‚¯
		this.validateExtractedData(extractedData);

		// é‡è¤‡ãƒã‚§ãƒƒã‚¯
		const duplicateCheck = await this.duplicateDetectionService.checkForDuplicates(
			userId,
			extractedData
		);

		if (duplicateCheck.hasDuplicates && !options.allowOverwrite) {
			return SalarySlipCreationResult.duplicate({
				fileName: file.name,
				duplicateInfo: duplicateCheck,
				extractedData
			});
		}

		// ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ä½œæˆ
		const salarySlip = SalarySlip.create({
			userId,
			companyName: extractedData.companyName,
			employeeName: extractedData.employeeName,
			employeeId: extractedData.employeeId,
			paymentDate: extractedData.paymentDate,
			targetPeriodStart: extractedData.targetPeriodStart,
			targetPeriodEnd: extractedData.targetPeriodEnd,
			attendance: AttendanceInfo.create(extractedData.attendance),
			earnings: EarningsDetail.create(extractedData.earnings),
			deductions: DeductionsDetail.create(extractedData.deductions),
			currency: extractedData.currency,
			sourceType: SalarySlipSourceType.PDF
		});

		// é‡è¤‡ãŒã‚ã‚‹å ´åˆã¯æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
		if (duplicateCheck.hasDuplicates && options.allowOverwrite) {
			const existingSalarySlip = await this.salarySlipRepository.findById(
				duplicateCheck.existingIds[0]
			);

			if (existingSalarySlip) {
				// æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
				existingSalarySlip.updateEarnings(salarySlip.earnings);
				existingSalarySlip.updateDeductions(salarySlip.deductions);
				await this.salarySlipRepository.save(existingSalarySlip);

				return SalarySlipCreationResult.updated({
					fileName: file.name,
					salarySlipId: existingSalarySlip.id,
					confidence: extractedData.confidence,
					previousData: duplicateCheck.existingData
				});
			}
		}

		// æ–°è¦ä¿å­˜
		await this.salarySlipRepository.save(salarySlip);

		// æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
		if (options.saveOriginalFile) {
			await this.saveAttachmentFile(salarySlip.id, file);
		}

		return SalarySlipCreationResult.success({
			fileName: file.name,
			salarySlipId: salarySlip.id,
			confidence: extractedData.confidence,
			extractedData
		});
	}

	private validateFiles(files: PdfFile[]): FileValidationResult {
		const errors: ValidationError[] = [];

		if (files.length === 0) {
			errors.push(new ValidationError('No files provided'));
		}

		if (files.length > 10) {
			errors.push(new ValidationError('Too many files. Maximum 10 files allowed.'));
		}

		for (const file of files) {
			// ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯
			if (file.size > 10 * 1024 * 1024) {
				// 10MB
				errors.push(new ValidationError(`File too large: ${file.name}`));
			}

			// ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ãƒã‚§ãƒƒã‚¯
			if (file.type !== 'application/pdf') {
				errors.push(new ValidationError(`Invalid file type: ${file.name}`));
			}

			// ãƒ•ã‚¡ã‚¤ãƒ«åãƒã‚§ãƒƒã‚¯
			if (!this.isValidFileName(file.name)) {
				errors.push(new ValidationError(`Invalid file name: ${file.name}`));
			}
		}

		return FileValidationResult.create({
			isValid: errors.length === 0,
			errors,
			validFiles: files.filter((f) => !errors.some((e) => e.message.includes(f.name)))
		});
	}

	private validateExtractedData(data: ExtractedSalarySlipData): void {
		if (!data.companyName || data.companyName.trim().length === 0) {
			throw new DataExtractionError('ä¼šç¤¾åã®æŠ½å‡ºã«å¤±æ•—ã—ã¾ã—ãŸ');
		}

		if (!data.employeeName || data.employeeName.trim().length === 0) {
			throw new DataExtractionError('å¾“æ¥­å“¡åã®æŠ½å‡ºã«å¤±æ•—ã—ã¾ã—ãŸ');
		}

		if (!data.paymentDate || isNaN(data.paymentDate.getTime())) {
			throw new DataExtractionError('æ”¯æ‰•æ—¥ã®æŠ½å‡ºã«å¤±æ•—ã—ã¾ã—ãŸ');
		}

		if (!data.earnings.baseSalary || MoneyAmount.from(data.earnings.baseSalary).isZero()) {
			throw new DataExtractionError('åŸºæœ¬çµ¦ã®æŠ½å‡ºã«å¤±æ•—ã—ã¾ã—ãŸ');
		}

		// è«–ç†çš„æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
		const totalEarnings = EarningsDetail.create(data.earnings).calculateTotal();
		const totalDeductions = DeductionsDetail.create(data.deductions).calculateTotal();
		const netPay = MoneyAmount.subtract(totalEarnings, totalDeductions);

		if (netPay.isNegative()) {
			throw new DataExtractionError('è¨ˆç®—çµæœãŒä¸æ­£ã§ã™ï¼ˆæ‰‹å–ã‚ŠãŒãƒã‚¤ãƒŠã‚¹ï¼‰');
		}
	}

	private isValidFileName(fileName: string): boolean {
		const validPattern = /^[a-zA-Z0-9\s\-_.()ï¼ˆï¼‰]+\.pdf$/i;
		return validPattern.test(fileName);
	}

	private createSummary(
		results: SalarySlipCreationResult[],
		warnings: ValidationWarning[]
	): ProcessingSummary {
		const successCount = results.filter((r) => r.isSuccess()).length;
		const failureCount = results.filter((r) => r.isFailure()).length;
		const duplicateCount = results.filter((r) => r.isDuplicate()).length;
		const updateCount = results.filter((r) => r.isUpdate()).length;

		return ProcessingSummary.create({
			totalProcessed: results.length,
			successCount,
			failureCount,
			duplicateCount,
			updateCount,
			warningCount: warnings.length,
			averageConfidence: this.calculateAverageConfidence(results),
			processingTimeMs: Date.now() // å®Ÿéš›ã«ã¯é–‹å§‹æ™‚åˆ»ã‹ã‚‰ã®çµŒéæ™‚é–“
		});
	}

	private calculateAverageConfidence(results: SalarySlipCreationResult[]): number {
		const successfulResults = results.filter((r) => r.isSuccess() || r.isUpdate());
		if (successfulResults.length === 0) return 0;

		const totalConfidence = successfulResults.reduce((sum, result) => sum + result.confidence, 0);
		return totalConfidence / successfulResults.length;
	}
}
```

### 3.2 ã‚¯ã‚¨ãƒªã‚µãƒ¼ãƒ“ã‚¹è¨­è¨ˆ

```typescript
// src/features/salary-slip/application/queries/salary-slip.query-service.ts

/**
 * çµ¦æ–™æ˜ç´°ã‚¯ã‚¨ãƒªã‚µãƒ¼ãƒ“ã‚¹
 *
 * @description èª­ã¿å–ã‚Šå°‚ç”¨ã®è¤‡é›‘ãªã‚¯ã‚¨ãƒªã‚’æ‹…å½“
 * CQRS ãƒ‘ã‚¿ãƒ¼ãƒ³ã«åŸºã¥ãèª­ã¿å–ã‚Šæœ€é©åŒ–
 */
export class SalarySlipQueryService {
	constructor(
		private readonly salarySlipRepository: SalarySlipRepository,
		private readonly statisticsService: SalaryStatisticsDomainService,
		private readonly cacheService: CacheService,
		private readonly logger: Logger
	) {}

	/**
	 * è©³ç´°æ¤œç´¢ã‚¯ã‚¨ãƒª
	 */
	async searchSalarySlips(
		query: SalarySlipSearchQuery
	): Promise<PaginatedResult<SalarySlipListView>> {
		const cacheKey = this.buildCacheKey('search', query);

		// ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å–å¾—ã‚’è©¦è¡Œ
		const cached = await this.cacheService.get<PaginatedResult<SalarySlipListView>>(cacheKey);
		if (cached) {
			this.logger.debug('Salary slip search cache hit', { cacheKey });
			return cached;
		}

		// æ¤œç´¢ä»•æ§˜ä½œæˆ
		const specification = this.buildSearchSpecification(query);

		// ãƒªãƒã‚¸ãƒˆãƒªã‹ã‚‰æ¤œç´¢
		const result = await this.salarySlipRepository.findBySpecification(query.userId, specification);

		// ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ‡ãƒ«ã«å¤‰æ›
		const viewResult = this.convertToListViews(result);

		// ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜ï¼ˆ30åˆ†ï¼‰
		await this.cacheService.set(cacheKey, viewResult, 1800);

		return viewResult;
	}

	/**
	 * çµ±è¨ˆãƒ‡ãƒ¼ã‚¿å–å¾—
	 */
	async getSalaryStatistics(query: SalaryStatisticsQuery): Promise<SalaryStatisticsView> {
		const cacheKey = this.buildCacheKey('statistics', query);

		const cached = await this.cacheService.get<SalaryStatisticsView>(cacheKey);
		if (cached) {
			return cached;
		}

		// æœŸé–“å†…ã®çµ¦æ–™æ˜ç´°ã‚’å–å¾—
		const salarySlips = await this.salarySlipRepository.findByDateRange(
			query.userId,
			query.dateRange
		);

		if (salarySlips.length === 0) {
			return SalaryStatisticsView.empty();
		}

		// çµ±è¨ˆè¨ˆç®—ï¼ˆãƒ‰ãƒ¡ã‚¤ãƒ³ã‚µãƒ¼ãƒ“ã‚¹ä½¿ç”¨ï¼‰
		let statistics: AnnualSalaryStatistics;

		if (query.type === 'annual') {
			statistics = this.statisticsService.calculateAnnualStatistics(salarySlips, query.year);
		} else {
			// æœˆæ¬¡çµ±è¨ˆã®å ´åˆ
			const monthlyTrends = this.statisticsService.calculateMonthlyTrends(
				salarySlips,
				query.periodMonths
			);
			statistics = this.convertMonthlyTrendsToAnnual(monthlyTrends);
		}

		// ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ‡ãƒ«ã«å¤‰æ›
		const view = this.convertStatisticsToView(statistics, query);

		// ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜ï¼ˆ2æ™‚é–“ï¼‰
		await this.cacheService.set(cacheKey, view, 7200);

		return view;
	}

	/**
	 * ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ç”¨ã‚µãƒãƒªãƒ¼å–å¾—
	 */
	async getDashboardSummary(query: DashboardSummaryQuery): Promise<DashboardSummaryView> {
		const cacheKey = this.buildCacheKey('dashboard', query);

		const cached = await this.cacheService.get<DashboardSummaryView>(cacheKey);
		if (cached) {
			return cached;
		}

		// ä¸¦åˆ—ã§è¤‡æ•°ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
		const [recentSalarySlips, currentYearStatistics, previousYearStatistics, monthlyTrends] =
			await Promise.all([
				this.getRecentSalarySlips(query.userId, 3),
				this.getYearlyStatistics(query.userId, query.currentYear),
				this.getYearlyStatistics(query.userId, query.currentYear - 1),
				this.getMonthlyTrends(query.userId, 12)
			]);

		// æˆé•·ç‡è¨ˆç®—
		const growthRate = this.calculateYearOverYearGrowth(
			currentYearStatistics,
			previousYearStatistics
		);

		// ã‚¢ãƒ©ãƒ¼ãƒˆç”Ÿæˆ
		const alerts = this.generateDashboardAlerts(recentSalarySlips, monthlyTrends);

		const view = DashboardSummaryView.create({
			recentSalarySlips: recentSalarySlips.map(this.convertToSummaryView),
			currentYearSummary: {
				totalIncome: currentYearStatistics.totalAnnualIncome,
				averageMonthlyIncome: currentYearStatistics.averageMonthlyIncome,
				totalTax: this.calculateTotalTax(currentYearStatistics),
				averageOvertimeHours: currentYearStatistics.averageOvertimeHours
			},
			growthMetrics: {
				incomeGrowthRate: growthRate.income,
				overtimeGrowthRate: growthRate.overtime,
				taxGrowthRate: growthRate.tax
			},
			monthlyTrends: monthlyTrends.trends,
			alerts,
			lastUpdated: new Date()
		});

		// ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜ï¼ˆ10åˆ†ï¼‰
		await this.cacheService.set(cacheKey, view, 600);

		return view;
	}

	/**
	 * ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆç”¨ãƒ‡ãƒ¼ã‚¿å–å¾—
	 */
	async getExportData(query: ExportDataQuery): Promise<SalarySlipExportData> {
		// ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ãªã„ï¼ˆãƒ‡ãƒ¼ã‚¿ã®ä¸€æ„æ€§ä¿è¨¼ã®ãŸã‚ï¼‰

		const specification = this.buildExportSpecification(query);
		const salarySlips = await this.salarySlipRepository.findBySpecification(
			query.userId,
			specification
		);

		// ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆåˆ¥ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ•´å½¢
		switch (query.format) {
			case 'csv':
				return this.formatForCSV(salarySlips);
			case 'excel':
				return this.formatForExcel(salarySlips);
			case 'pdf':
				return this.formatForPDF(salarySlips);
			default:
				return this.formatForJSON(salarySlips);
		}
	}

	// ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ã‚½ãƒƒãƒ‰
	private buildSearchSpecification(query: SalarySlipSearchQuery): SalarySlipSpecification {
		const builder = new SalarySlipSpecificationBuilder();

		if (query.status) {
			builder.withStatus(query.status);
		}

		if (query.companyName) {
			builder.withCompanyName(query.companyName);
		}

		if (query.dateRange) {
			builder.withDateRange(query.dateRange.start, query.dateRange.end);
		}

		if (query.amountRange) {
			builder.withAmountRange(query.amountRange.min, query.amountRange.max);
		}

		if (query.searchText) {
			builder.withFullTextSearch(query.searchText);
		}

		builder.withPagination(query.pagination.page, query.pagination.limit);
		builder.withSorting(query.sortBy, query.sortOrder);

		return builder.build();
	}

	private convertToListViews(
		result: PaginatedResult<SalarySlip>
	): PaginatedResult<SalarySlipListView> {
		const listViews = result.data.map((salarySlip) =>
			SalarySlipListView.create({
				id: salarySlip.id.value,
				companyName: salarySlip.companyName,
				employeeName: salarySlip.employeeName,
				paymentDate: salarySlip.paymentDate.toISOString(),
				totalEarnings: salarySlip.totalEarnings.value,
				totalDeductions: salarySlip.totalDeductions.value,
				netPay: salarySlip.netPay.value,
				status: salarySlip.status,
				sourceType: salarySlip.sourceType,
				createdAt: salarySlip.createdAt.toISOString(),
				// è¡¨ç¤ºç”¨ã®è¿½åŠ æƒ…å ±
				displayMonth: this.formatDisplayMonth(salarySlip.paymentDate),
				overtimeHours:
					salarySlip.attendance.overtimeHours + salarySlip.attendance.overtimeHoursOver60,
				hasAttachment: false // TODO: æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ‰ç„¡ã‚’åˆ¤å®š
			})
		);

		return new PaginatedResult(listViews, result.total, result.pagination);
	}

	private buildCacheKey(type: string, query: any): string {
		const queryHash = this.hashObject(query);
		return `salary_slip:${type}:${queryHash}`;
	}

	private hashObject(obj: any): string {
		return Buffer.from(JSON.stringify(obj)).toString('base64');
	}

	private formatDisplayMonth(date: Date): string {
		return date.toLocaleDateString('ja-JP', {
			year: 'numeric',
			month: 'long'
		});
	}
}
```

---

## 4. Repository ãƒ‘ã‚¿ãƒ¼ãƒ³è¨­è¨ˆ

### 4.1 Repository ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹è¨­è¨ˆ

```typescript
// src/features/salary-slip/domain/repositories/salary-slip.repository.ts

/**
 * çµ¦æ–™æ˜ç´°ãƒªãƒã‚¸ãƒˆãƒªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
 *
 * @description ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤ã§ã®æ°¸ç¶šåŒ–æŠ½è±¡åŒ–
 * ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£å±¤ã®å®Ÿè£…ã‹ã‚‰ç‹¬ç«‹
 */
export interface SalarySlipRepository {
	/**
	 * ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®ä¿å­˜
	 */
	save(salarySlip: SalarySlip): Promise<void>;

	/**
	 * ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®å‰Šé™¤
	 */
	delete(id: EntityId): Promise<void>;

	/**
	 * IDã«ã‚ˆã‚‹å˜ä¸€å–å¾—
	 */
	findById(id: EntityId): Promise<SalarySlip | null>;

	/**
	 * IDã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã«ã‚ˆã‚‹å–å¾—
	 */
	findByIdAndUserId(id: EntityId, userId: EntityId): Promise<SalarySlip | null>;

	/**
	 * ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã«ã‚ˆã‚‹ä¸€è¦§å–å¾—ï¼ˆãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãï¼‰
	 */
	findByUserId(
		userId: EntityId,
		pagination: PaginationOptions
	): Promise<PaginatedResult<SalarySlip>>;

	/**
	 * ä»•æ§˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã‚ˆã‚‹æ¤œç´¢
	 */
	findBySpecification(
		userId: EntityId,
		specification: SalarySlipSpecification
	): Promise<PaginatedResult<SalarySlip>>;

	/**
	 * æ”¯æ‰•æ—¥ã«ã‚ˆã‚‹æ¤œç´¢ï¼ˆé‡è¤‡ãƒã‚§ãƒƒã‚¯ç”¨ï¼‰
	 */
	findByPaymentDate(userId: EntityId, paymentDate: Date): Promise<SalarySlip | null>;

	/**
	 * æ—¥ä»˜ç¯„å›²ã«ã‚ˆã‚‹æ¤œç´¢
	 */
	findByDateRange(userId: EntityId, dateRange: DateRange): Promise<SalarySlip[]>;

	/**
	 * çµ±è¨ˆè¨ˆç®—ç”¨ã®é›†ç´„ã‚¯ã‚¨ãƒª
	 */
	calculateStatistics(userId: EntityId, period: StatisticsPeriod): Promise<SalarySlipStatistics>;

	/**
	 * ãƒãƒ«ã‚¯æ“ä½œã‚µãƒãƒ¼ãƒˆ
	 */
	saveMany(salarySlips: SalarySlip[]): Promise<void>;

	/**
	 * å­˜åœ¨ç¢ºèª
	 */
	exists(id: EntityId): Promise<boolean>;

	/**
	 * ã‚«ã‚¦ãƒ³ãƒˆå–å¾—
	 */
	countByUserId(userId: EntityId): Promise<number>;
}
```

### 4.2 ä»•æ§˜ãƒ‘ã‚¿ãƒ¼ãƒ³å®Ÿè£…

```typescript
// src/features/salary-slip/domain/specifications/salary-slip.specification.ts

/**
 * çµ¦æ–™æ˜ç´°æ¤œç´¢ä»•æ§˜
 *
 * @description ä»•æ§˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã‚ˆã‚‹è¤‡é›‘ãªæ¤œç´¢æ¡ä»¶ã®æŠ½è±¡åŒ–
 */
export class SalarySlipSpecification {
	private constructor(
		public readonly status?: SalarySlipStatus,
		public readonly companyName?: string,
		public readonly dateRange?: DateRange,
		public readonly amountRange?: MoneyAmountRange,
		public readonly searchQuery?: string,
		public readonly pagination: PaginationOptions = { page: 1, limit: 20 },
		public readonly sortBy: string = 'paymentDate',
		public readonly sortOrder: 'asc' | 'desc' = 'desc'
	) {}

	public static create(criteria: SalarySlipSearchCriteria): SalarySlipSpecification {
		return new SalarySlipSpecification(
			criteria.status,
			criteria.companyName,
			criteria.dateRange,
			criteria.amountRange,
			criteria.searchQuery,
			criteria.pagination,
			criteria.sortBy,
			criteria.sortOrder
		);
	}

	/**
	 * ä»•æ§˜ã®åˆæˆ
	 */
	public and(other: SalarySlipSpecification): CompositeSpecification {
		return new CompositeSpecification([this, other], 'AND');
	}

	public or(other: SalarySlipSpecification): CompositeSpecification {
		return new CompositeSpecification([this, other], 'OR');
	}

	/**
	 * ä»•æ§˜ã‚’æº€ãŸã™ã‹ã©ã†ã‹ã®åˆ¤å®š
	 */
	public isSatisfiedBy(salarySlip: SalarySlip): boolean {
		if (this.status && salarySlip.status !== this.status) {
			return false;
		}

		if (
			this.companyName &&
			!salarySlip.companyName.toLowerCase().includes(this.companyName.toLowerCase())
		) {
			return false;
		}

		if (this.dateRange && !this.dateRange.contains(salarySlip.paymentDate)) {
			return false;
		}

		if (this.amountRange && !this.amountRange.contains(salarySlip.netPay)) {
			return false;
		}

		if (this.searchQuery && !this.matchesSearchQuery(salarySlip, this.searchQuery)) {
			return false;
		}

		return true;
	}

	private matchesSearchQuery(salarySlip: SalarySlip, query: string): boolean {
		const searchText = query.toLowerCase();

		return (
			salarySlip.companyName.toLowerCase().includes(searchText) ||
			salarySlip.employeeName.toLowerCase().includes(searchText) ||
			salarySlip.employeeId.toLowerCase().includes(searchText)
		);
	}
}

/**
 * ä»•æ§˜ãƒ“ãƒ«ãƒ€ãƒ¼
 */
export class SalarySlipSpecificationBuilder {
	private status?: SalarySlipStatus;
	private companyName?: string;
	private dateRange?: DateRange;
	private amountRange?: MoneyAmountRange;
	private searchQuery?: string;
	private pagination: PaginationOptions = { page: 1, limit: 20 };
	private sortBy: string = 'paymentDate';
	private sortOrder: 'asc' | 'desc' = 'desc';

	public withStatus(status: SalarySlipStatus): this {
		this.status = status;
		return this;
	}

	public withCompanyName(companyName: string): this {
		this.companyName = companyName;
		return this;
	}

	public withDateRange(start: Date, end: Date): this {
		this.dateRange = new DateRange(start, end);
		return this;
	}

	public withAmountRange(min: MoneyAmount, max: MoneyAmount): this {
		this.amountRange = new MoneyAmountRange(min, max);
		return this;
	}

	public withFullTextSearch(query: string): this {
		this.searchQuery = query;
		return this;
	}

	public withPagination(page: number, limit: number): this {
		this.pagination = { page, limit };
		return this;
	}

	public withSorting(sortBy: string, sortOrder: 'asc' | 'desc'): this {
		this.sortBy = sortBy;
		this.sortOrder = sortOrder;
		return this;
	}

	public build(): SalarySlipSpecification {
		return new SalarySlipSpecification(
			this.status,
			this.companyName,
			this.dateRange,
			this.amountRange,
			this.searchQuery,
			this.pagination,
			this.sortBy,
			this.sortOrder
		);
	}
}
```

---

## 5. ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•è¨­è¨ˆ

### 5.1 ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆè¨­è¨ˆ

```typescript
// src/shared/domain/events/domain-event.ts

/**
 * ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆåŸºåº•ã‚¯ãƒ©ã‚¹
 */
export abstract class DomainEvent {
	public readonly eventId: string;
	public readonly occurredOn: Date;
	public readonly version: number;

	protected constructor(
		public readonly aggregateId: EntityId,
		version: number = 1
	) {
		this.eventId = cuid();
		this.occurredOn = new Date();
		this.version = version;
	}

	abstract get eventType(): string;
}

// src/entities/salary-slip/domain/events/salary-slip-created.event.ts

/**
 * çµ¦æ–™æ˜ç´°ä½œæˆã‚¤ãƒ™ãƒ³ãƒˆ
 */
export class SalarySlipCreatedEvent extends DomainEvent {
	constructor(public readonly salarySlip: SalarySlip) {
		super(salarySlip.id);
	}

	get eventType(): string {
		return 'SalarySlipCreated';
	}

	public toJSON(): any {
		return {
			eventId: this.eventId,
			eventType: this.eventType,
			aggregateId: this.aggregateId.value,
			occurredOn: this.occurredOn.toISOString(),
			version: this.version,
			data: {
				salarySlipId: this.salarySlip.id.value,
				userId: this.salarySlip.userId.value,
				companyName: this.salarySlip.companyName,
				paymentDate: this.salarySlip.paymentDate.toISOString(),
				totalEarnings: this.salarySlip.totalEarnings.value,
				netPay: this.salarySlip.netPay.value,
				sourceType: this.salarySlip.sourceType
			}
		};
	}
}
```

### 5.2 ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼è¨­è¨ˆ

```typescript
// src/features/salary-slip/application/event-handlers/salary-slip-created.event-handler.ts

/**
 * çµ¦æ–™æ˜ç´°ä½œæˆã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
 */
@EventHandler(SalarySlipCreatedEvent)
export class SalarySlipCreatedEventHandler {
  constructor(
    private readonly notificationService: NotificationService,
    private readonly analyticsService: AnalyticsService,
    private readonly cacheService: CacheService,
    private readonly logger: Logger
  ) {}

  async handle(event: SalarySlipCreatedEvent): Promise<void> {
    this.logger.info('Handling SalarySlipCreatedEvent', {
      eventId: event.eventId,
      salarySlipId: event.salarySlip.id.value
    });

    try {
      // ä¸¦åˆ—å‡¦ç†ã§è¤‡æ•°ã®å‰¯ä½œç”¨ã‚’å®Ÿè¡Œ
      await Promise.allSettled([
        this.sendNotification(event),
        this.trackAnalytics(event),
        this.invalidateCache(event),
        this.updateStatistics(event)
      ]);

      this.logger.info('SalarySlipCreatedEvent handled successfully', {
        eventId: event.eventId
      });
    } catch (error) {
      this.logger.error('Failed to handle SalarySlipCreatedEvent', {
        eventId: event.eventId,
        error: error.message
      });

      // ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯è£œå„Ÿãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œ
      await this.executeCompensation(event);
      throw error;
    }
  }

  private async sendNotification(event: SalarySlipCreatedEvent): Promise<void> {
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®é€šçŸ¥è¨­å®šã‚’ç¢ºèª
    const shouldNotify = await this.notificationService.shouldNotifyForSalarySlipCreation(
      event.salarySlip.userId
    );

    if (!shouldNotify) return;

    // é€šçŸ¥ã‚’é€ä¿¡
    await this.notificationService.send(
      NotificationRequest.create({
        userId: event.salarySlip.userId,
        type: 'SALARY_SLIP_CREATED',
        title: 'æ–°ã—ã„çµ¦æ–™æ˜ç´°ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸ',
        message: `${event.salarySlip.companyName}ã®${this.formatPaymentMonth(event.salarySlip.paymentDate)}åˆ†ã®çµ¦æ–™æ˜ç´°ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚`,
        data: {
          salarySlipId: event.salarySlip.id.value,
          netPay: event.salarySlip.netPay.value
        }
      })
    );
  }

  private async trackAnalytics(event: SalarySlipCreatedEvent): Promise<void> {
    await this.analyticsService.track('salary_slip_created', {
      userId: event.salarySlip.userId.value,
      companyName: event.salarySlip.companyName,
      sourceType: event.salarySlip.sourceType,
      netPayAmount: event.salarySlip.netPay.toNumber(),
      processingDate: new Date().toISOString()
    });
  }

  private async invalidateCache(event: SalarySlipCreatedEvent): Promise<void> {
    const userId = event.salarySlip.userId.value;

    // é–¢é€£ã™ã‚‹ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚­ãƒ¼ã‚’å‰Šé™¤
    await Promise.all([
      this.cacheService.deleteByPattern(`salary_slip:search:*${userId}*`),
      this.cacheService.deleteByPattern(`salary_slip:statistics:*${userId}*`),
      this.cacheService.deleteByPattern(`salary_slip:dashboard:*${userId}*`)
    ]);
  }

  private async updateStatistics(event: SalarySlipCreatedEvent): Promise<void> {
    // çµ±è¨ˆãƒ‡ãƒ¼ã‚¿ã®å³åº§æ›´æ–°ï¼ˆãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§å®Ÿè¡Œï¼‰
    await this.analyticsService.updateUserStatistics(event.salarySlip.userId);
  }

  private async executeCompensation(event: SalarySlipCreatedEvent): Promise<void> {
    // ã‚¨ãƒ©ãƒ¼æ™‚ã®è£œå„Ÿå‡¦ç†ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
    this.logger.info('Executing compensation for SalarySlipCreatedEvent', {
      eventId: event.eventId
    });
  }

  private formatPaymentMonth(date: Date): string {
    return date.toLocaleDateString('ja-JP', {
      year: 'numeric',
      month: 'long'
    });
  }
}
```

---

## 6. ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ç®¡ç†

### 6.1 Unit of Work ãƒ‘ã‚¿ãƒ¼ãƒ³

```typescript
// src/shared/infrastructure/unit-of-work/unit-of-work.ts

/**
 * Unit of Work ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
 */
export interface UnitOfWork {
	/**
	 * ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³é–‹å§‹
	 */
	begin(): Promise<void>;

	/**
	 * ã‚³ãƒŸãƒƒãƒˆ
	 */
	commit(): Promise<void>;

	/**
	 * ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
	 */
	rollback(): Promise<void>;

	/**
	 * ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å†…ã§ã®æ“ä½œå®Ÿè¡Œ
	 */
	withTransaction<T>(operation: (uow: UnitOfWork) => Promise<T>): Promise<T>;

	/**
	 * ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã«ç™»éŒ²
	 */
	registerNew<T>(entity: T, repository: Repository<T>): void;
	registerDirty<T>(entity: T, repository: Repository<T>): void;
	registerDeleted<T>(entity: T, repository: Repository<T>): void;

	/**
	 * å¤‰æ›´ã®ã‚³ãƒŸãƒƒãƒˆ
	 */
	commitChanges(): Promise<void>;
}

/**
 * Prisma Unit of Work å®Ÿè£…
 */
export class PrismaUnitOfWork implements UnitOfWork {
	private prismaTransaction?: Prisma.TransactionClient;
	private isTransactionActive = false;
	private newEntities = new Map<Repository<any>, any[]>();
	private dirtyEntities = new Map<Repository<any>, any[]>();
	private deletedEntities = new Map<Repository<any>, any[]>();

	constructor(
		private readonly prisma: PrismaClient,
		private readonly logger: Logger
	) {}

	async begin(): Promise<void> {
		if (this.isTransactionActive) {
			throw new TransactionError('Transaction is already active');
		}

		this.logger.debug('Beginning transaction');
		this.isTransactionActive = true;
	}

	async commit(): Promise<void> {
		if (!this.isTransactionActive) {
			throw new TransactionError('No active transaction to commit');
		}

		try {
			await this.commitChanges();
			this.logger.debug('Transaction committed successfully');
		} catch (error) {
			this.logger.error('Failed to commit transaction', { error });
			throw error;
		} finally {
			this.cleanup();
		}
	}

	async rollback(): Promise<void> {
		if (!this.isTransactionActive) {
			this.logger.warn('No active transaction to rollback');
			return;
		}

		try {
			this.logger.debug('Rolling back transaction');
			this.cleanup();
		} catch (error) {
			this.logger.error('Error during rollback', { error });
			throw error;
		}
	}

	async withTransaction<T>(operation: (uow: UnitOfWork) => Promise<T>): Promise<T> {
		return this.prisma.$transaction(async (prismaTransaction) => {
			this.prismaTransaction = prismaTransaction;
			this.isTransactionActive = true;

			try {
				const result = await operation(this);
				await this.commitChanges();
				return result;
			} catch (error) {
				this.logger.error('Transaction operation failed', { error });
				throw error;
			} finally {
				this.cleanup();
			}
		});
	}

	registerNew<T>(entity: T, repository: Repository<T>): void {
		this.addToCollection(this.newEntities, repository, entity);
	}

	registerDirty<T>(entity: T, repository: Repository<T>): void {
		this.addToCollection(this.dirtyEntities, repository, entity);
	}

	registerDeleted<T>(entity: T, repository: Repository<T>): void {
		this.addToCollection(this.deletedEntities, repository, entity);
	}

	async commitChanges(): Promise<void> {
		const prismaClient = this.prismaTransaction || this.prisma;

		try {
			// å‰Šé™¤å‡¦ç†
			for (const [repository, entities] of this.deletedEntities) {
				for (const entity of entities) {
					await repository.delete(entity.id, prismaClient);
				}
			}

			// æ–°è¦ä½œæˆå‡¦ç†
			for (const [repository, entities] of this.newEntities) {
				for (const entity of entities) {
					await repository.create(entity, prismaClient);
				}
			}

			// æ›´æ–°å‡¦ç†
			for (const [repository, entities] of this.dirtyEntities) {
				for (const entity of entities) {
					await repository.update(entity, prismaClient);
				}
			}

			this.logger.debug('All changes committed successfully', {
				newCount: Array.from(this.newEntities.values()).flat().length,
				dirtyCount: Array.from(this.dirtyEntities.values()).flat().length,
				deletedCount: Array.from(this.deletedEntities.values()).flat().length
			});
		} catch (error) {
			this.logger.error('Failed to commit changes', { error });
			throw error;
		}
	}

	private addToCollection<T>(
		collection: Map<Repository<T>, T[]>,
		repository: Repository<T>,
		entity: T
	): void {
		if (!collection.has(repository)) {
			collection.set(repository, []);
		}
		collection.get(repository)!.push(entity);
	}

	private cleanup(): void {
		this.isTransactionActive = false;
		this.prismaTransaction = undefined;
		this.newEntities.clear();
		this.dirtyEntities.clear();
		this.deletedEntities.clear();
	}
}
```

---

## 7. ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°æˆ¦ç•¥

### 7.1 å¤šå±¤ã‚­ãƒ£ãƒƒã‚·ãƒ¥è¨­è¨ˆ

```typescript
// src/shared/infrastructure/cache/cache.service.ts

/**
 * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µãƒ¼ãƒ“ã‚¹
 */
export interface CacheService {
	get<T>(key: string): Promise<T | null>;
	set<T>(key: string, value: T, ttlSeconds: number): Promise<void>;
	delete(key: string): Promise<void>;
	deleteByPattern(pattern: string): Promise<void>;
	exists(key: string): Promise<boolean>;
	clear(): Promise<void>;
}

/**
 * å¤šå±¤ã‚­ãƒ£ãƒƒã‚·ãƒ¥å®Ÿè£…
 */
export class MultiLayerCacheService implements CacheService {
	constructor(
		private readonly memoryCache: MemoryCache,
		private readonly redisCache: RedisCache,
		private readonly logger: Logger
	) {}

	async get<T>(key: string): Promise<T | null> {
		try {
			// L1: ãƒ¡ãƒ¢ãƒªã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å–å¾—è©¦è¡Œ
			let value = await this.memoryCache.get<T>(key);
			if (value !== null) {
				this.logger.debug('Cache hit (L1)', { key });
				return value;
			}

			// L2: Redisã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å–å¾—è©¦è¡Œ
			value = await this.redisCache.get<T>(key);
			if (value !== null) {
				this.logger.debug('Cache hit (L2)', { key });
				// L1ã«ã‚‚ä¿å­˜ï¼ˆçŸ­ã„TTLï¼‰
				await this.memoryCache.set(key, value, 300); // 5åˆ†
				return value;
			}

			this.logger.debug('Cache miss', { key });
			return null;
		} catch (error) {
			this.logger.error('Cache get error', { key, error });
			return null;
		}
	}

	async set<T>(key: string, value: T, ttlSeconds: number): Promise<void> {
		try {
			// ä¸¡æ–¹ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
			await Promise.all([
				this.memoryCache.set(key, value, Math.min(ttlSeconds, 300)), // L1ã¯æœ€å¤§5åˆ†
				this.redisCache.set(key, value, ttlSeconds)
			]);

			this.logger.debug('Cache set', { key, ttl: ttlSeconds });
		} catch (error) {
			this.logger.error('Cache set error', { key, error });
		}
	}

	async delete(key: string): Promise<void> {
		try {
			await Promise.all([this.memoryCache.delete(key), this.redisCache.delete(key)]);

			this.logger.debug('Cache delete', { key });
		} catch (error) {
			this.logger.error('Cache delete error', { key, error });
		}
	}

	async deleteByPattern(pattern: string): Promise<void> {
		try {
			await Promise.all([
				this.memoryCache.deleteByPattern(pattern),
				this.redisCache.deleteByPattern(pattern)
			]);

			this.logger.debug('Cache pattern delete', { pattern });
		} catch (error) {
			this.logger.error('Cache pattern delete error', { pattern, error });
		}
	}

	async exists(key: string): Promise<boolean> {
		try {
			// ã©ã¡ã‚‰ã‹ã«ã‚ã‚Œã°true
			const [memoryExists, redisExists] = await Promise.all([
				this.memoryCache.exists(key),
				this.redisCache.exists(key)
			]);

			return memoryExists || redisExists;
		} catch (error) {
			this.logger.error('Cache exists error', { key, error });
			return false;
		}
	}

	async clear(): Promise<void> {
		try {
			await Promise.all([this.memoryCache.clear(), this.redisCache.clear()]);

			this.logger.info('Cache cleared');
		} catch (error) {
			this.logger.error('Cache clear error', { error });
		}
	}
}
```

---

## 8. æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

1. âœ… ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯è¨­è¨ˆï¼ˆæœ¬æ›¸ï¼‰
2. â†’ ãƒ‡ã‚¶ã‚¤ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³é©ç”¨è¨­è¨ˆ
3. â†’ å®Ÿè£…ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ä½œæˆ
4. â†’ ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆæˆ¦ç•¥å®šç¾©
5. â†’ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°æŒ‡é‡
6. â†’ å®Ÿè£…ãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹

---

## æ‰¿èª

| å½¹å‰²                         | åå‰                         | æ—¥ä»˜       | ç½²å |
| ---------------------------- | ---------------------------- | ---------- | ---- |
| ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒˆ | ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒˆ | 2025-08-10 | âœ…   |
| ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼                   | -                            | -          | [ ]  |
| æ‰¿èªè€…                       | -                            | -          | [ ]  |

---

**æ”¹è¨‚å±¥æ­´**

| ãƒãƒ¼ã‚¸ãƒ§ãƒ³ | æ—¥ä»˜       | å¤‰æ›´å†…å®¹ | ä½œæˆè€…                       |
| ---------- | ---------- | -------- | ---------------------------- |
| 1.0.0      | 2025-08-10 | åˆç‰ˆä½œæˆ | ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒˆ |
